<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Album Viewer (Web)</title>
    <style>
        /* CSS Reset cho di ƒë·ªông */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
        }
        body {
            background-color: #121212;
            color: #ccc;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            height: 100vh;
            width: 100vw;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden; /* Ch·∫∑n cu·ªôn trang */
        }

        /* Giao di·ªán ch√≠nh (Lu√¥n hi·ªán) */
        #gameUI {
            display: flex; /* M·∫∑c ƒë·ªãnh hi·ªán */
            width: 100%; height: 100%;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        /* Viewport */
        #viewport {
            width: 100%;
            height: 100%;
            background-color: #000;
            position: relative;
            overflow: hidden;
            cursor: none;
        }
        #stage {
            position: absolute; top: 0; left: 0;
            transform-origin: 0 0;
            background-repeat: no-repeat;
            background-size: 100% 100%;
        }
        canvas { 
            display: block; 
            transition: opacity 0.1s;
            transform: translateZ(0); 
        }
        
        #statusMsg {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8); color: white;
            padding: 10px 20px; border-radius: 5px;
            display: none; z-index: 200;
        }
        
        /* --- C√îNG C·ª§ HI·ªÇN TH·ªä (Offset Cursor & Loupe) --- */
        #touchCursor {
            position: fixed;
            pointer-events: none;
            border: 2px dashed #FFF;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 9999;
            display: none;
            transition: width 0.1s, height 0.1s, border-color 0.2s;
        }
        #loupeDiv {
            position: fixed;
            pointer-events: none;
            border: 3px solid #00e5ff; /* M·ªèng h∆°n cho iPhone */
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 9998;
            display: none;
            overflow: hidden;
            background-repeat: no-repeat;
        }

        /* --- THANH C√îNG C·ª§ D·ªåC (Sidebar) - Thu nh·ªè cho iPhone --- */
        .sidebar-wrapper {
            position: fixed;
            top: 0;
            right: 0; /* M·∫∑c ƒë·ªãnh b√™n ph·∫£i */
            height: 100%;
            display: flex;
            align-items: center;
            z-index: 100;
            transition: transform 0.3s ease-out;
        }
        .sidebar-wrapper.hidden { transform: translateX(100%); }
        .sidebar-wrapper.left.hidden { transform: translateX(-100%); }
        .sidebar-wrapper.left { right: auto; left: 0; }
        
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 10px; /* Thu h·∫πp */
            align-items: center;
            background: rgba(30, 30, 30, 0.9);
            backdrop-filter: blur(10px);
            padding: 10px; /* Thu h·∫πp */
            height: auto;
            max-height: 95%;
            border-radius: 12px;
            border: 1px solid #444;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .sidebar-wrapper:not(.left) .sidebar { margin-right: 5px; } /* G·∫ßn m√©p h∆°n */
        .sidebar-wrapper.left .sidebar { margin-left: 5px; }
        
        .divider { width: 80%; height: 1px; background: #555; }

        .tool-btn {
            font-size: 18px; /* Thu nh·ªè */
            background: #555;
            color: #fff;
            border: none;
            width: 40px; height: 40px; /* Thu nh·ªè */
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        .tool-btn:active { background: #777; }
        
        #hideUIBtn {
            position: absolute;
            top: 50%;
            left: -30px; 
            transform: translateY(-50%);
            width: 18px; height: 50px; /* Thu nh·ªè */
            border-radius: 8px 0 0 8px;
            font-size: 14px;
            padding: 0;
            background: #333;
            border: 1px solid #444;
            border-right: none;
        }
        .sidebar-wrapper.left #hideUIBtn {
            left: auto;
            right: -30px;
            border-radius: 0 8px 8px 0;
            border-right: 1px solid #444;
            border-left: none;
        }
        
        #showUIBtn {
            position: fixed;
            top: 50%;
            right: 0; 
            transform: translateY(-50%);
            width: 18px; height: 50px; /* Thu nh·ªè */
            border-radius: 8px 0 0 8px;
            font-size: 14px;
            padding: 0;
            background: #333;
            border: 1px solid #444;
            border-right: none;
            z-index: 99;
            display: none;
        }
        #showUIBtn.left {
            right: auto;
            left: 0;
            border-radius: 0 8px 8px 0;
            border-right: 1px solid #444;
            border-left: none;
        }

        .image-info { 
            font-family: monospace; color: #eee; font-weight: bold;
            font-size: 14px;
        }
        
        .size-display { font-size: 12px; color: #999; margin: 5px 0; }
        
        .tool-btn.active { background: #00e5ff; color: #000; }
        .tool-btn#eraser.active { background: #ff9800; }
        .tool-btn#restore.active { background: #4CAF50; }
        
    </style>
</head>
<body>

    <div id="gameUI">
        <div id="statusMsg">Loading...</div>

        <div id="viewport">
            <div id="stage">
                <canvas id="gameCanvas"></canvas>
            </div>
        </div>
        
        <div id="touchCursor"></div>
        <div id="loupeDiv"></div>
        
        <button id="showUIBtn" onclick="toggleUI(true)">‚ü®</button>

        <div class="sidebar-wrapper" id="sidebarWrapper">
            <div class="sidebar">
                <button id="hideUIBtn" onclick="toggleUI(false)">‚ü©</button>
            
                <button class="tool-btn" onclick="prevImage()" title="·∫¢nh tr∆∞·ªõc">‚¨ÖÔ∏è</button>
                <div class="image-info" id="imgCounter">--</div>
                <button class="tool-btn" onclick="nextImage()" title="·∫¢nh sau">‚û°Ô∏è</button>
                
                <div class="divider"></div>
                
                <button class="tool-btn" id="loupe" onclick="setTool('loupe')" title="K√≠nh L√∫p">üîé</button>
                <button class="tool-btn" id="eraser" onclick="setTool('eraser')" title="C·ª•c T·∫©y">üßº</button>
                <button class="tool-btn" id="restore" onclick="setTool('restore')" title="Kh√¥i Ph·ª•c">üñåÔ∏è</button>
                <button class="tool-btn" id="viewBtn" ontouchstart="toggleView(true)" ontouchend="toggleView(false)" title="Gi·ªØ ƒë·ªÉ xem Edit">üëÄ</button>
                
                <div class="divider"></div>
                
                <button class="tool-btn" onclick="changeBrushSize(20)" title="TƒÉng C·ª°">+</button>
                <span class="size-display" id="brushSizeDisplay">50px</span>
                <button class="tool-btn" onclick="changeBrushSize(-20)" title="Gi·∫£m C·ª°">-</button>
                
                <div class="divider"></div>

                <button class="tool-btn" onclick="resetView()" title="Reset View (Zoom/Pan)">üéØ</button>
                <button class="tool-btn" onclick="resetDrawing()" title="Reset ·∫¢nh (X√≥a v·∫øt t·∫©y)">üîÑ</button>
                <button class="tool-btn" onclick="swapSide()" title="Chuy·ªÉn b√™n Tr√°i/Ph·∫£i">‚ÜîÔ∏è</button>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const statusMsg = document.getElementById('statusMsg');
        const viewport = document.getElementById('viewport');
        const stage = document.getElementById('stage');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const imgCounter = document.getElementById('imgCounter');
        
        const touchCursor = document.getElementById('touchCursor');
        const loupeDiv = document.getElementById('loupeDiv');
        const brushSizeDisplay = document.getElementById('brushSizeDisplay');
        const toolButtons = {
            loupe: document.getElementById('loupe'),
            eraser: document.getElementById('eraser'),
            restore: document.getElementById('restore')
        };

        const sidebarWrapper = document.getElementById('sidebarWrapper');
        const hideUIBtn = document.getElementById('hideUIBtn');
        const showUIBtn = document.getElementById('showUIBtn');

        // --- Logic Vars ---
        const imgOriginal = new Image();
        let currentEditURL = '';
        let currentImageIndex = 1; // B·∫Øt ƒë·∫ßu t·ª´ 1
        let brushSize = 50;
        let scale = 1; let panX = 0; let panY = 0;
        
        const TOUCH_OFFSET_Y = -60; // Gi·∫£m offset cho iPhone
        let isDrawing = false; 
        let isGesturing = false;
        
        let lastPanMidpoint = null;
        let lastPinchDist = 0;

        let currentTool = 'loupe';
        let isSwitching = false;

        // --- T·ª∞ ƒê·ªòNG CH·∫†Y KHI M·ªû FILE ---
        window.onload = () => {
            setTool('loupe'); // ƒê·∫∑t tool m·∫∑c ƒë·ªãnh
            loadPair(1); // T·ª± ƒë·ªông load ·∫£nh s·ªë 1
        };

        // --- LOAD ·∫¢NH (Logic Web-Hosted) ---
        function loadPair(index) {
            if (index < 1) return; // Kh√¥ng cho l√πi v·ªÅ 0
            if (isSwitching) return;
            
            isSwitching = true;
            statusMsg.style.display = 'block';
            
            // T√¨m file trong c√πng th∆∞ m·ª•c (v√≠ d·ª•: "1o.jpg")
            const urlO = `${index}o.jpg`;
            const urlE = `${index}e.jpg`;

            // D√πng 1 ·∫£nh t·∫°m ƒë·ªÉ ki·ªÉm tra
            const temp = new Image();
            
            temp.onload = () => {
                // N·∫øu ·∫£nh t·∫°m t·∫£i OK
                imgOriginal.onload = () => {
                    canvas.width = imgOriginal.naturalWidth;
                    canvas.height = imgOriginal.naturalHeight;
                    stage.style.width = canvas.width + "px";
                    stage.style.height = canvas.height + "px";
                    
                    stage.style.backgroundImage = `url('${urlE}')`;
                    loupeDiv.style.backgroundImage = `url('${urlE}')`;
                    
                    resetView();
                    drawFullOriginal();
                    statusMsg.style.display = 'none';
                    isSwitching = false;
                    currentImageIndex = index; // C·∫≠p nh·∫≠t index
                };
                imgOriginal.onerror = () => { 
                    statusMsg.style.display = 'none';
                    isSwitching = false;
                    alert(`L·ªói: Kh√¥ng t·∫£i ƒë∆∞·ª£c ·∫£nh ${urlE}`);
                };
                imgCounter.innerText = `·∫¢nh ${index}`;
                imgOriginal.src = urlO;
                currentEditURL = urlE;
            };
            
            temp.onerror = () => {
                // N·∫øu ·∫£nh t·∫°m (1o.jpg) t·∫£i l·ªói (404)
                statusMsg.style.display = 'none';
                isSwitching = false;
                if (index > 1) { // Ch·ªâ b√°o l·ªói n·∫øu ƒëang b·∫•m Next
                    alert("ƒê√£ h·∫øt ·∫£nh trong album n√†y.");
                } else {
                    alert("L·ªói: Kh√¥ng t√¨m th·∫•y file '1o.jpg'. H√£y ch·∫Øc ch·∫Øn b·∫°n ƒë√£ upload ·∫£nh.");
                }
            };
            
            temp.src = urlO; // B·∫Øt ƒë·∫ßu t·∫£i ·∫£nh t·∫°m
        }

        // --- H√ÄM V·∫º & RESET ---
        function drawFullOriginal() {
            ctx.globalCompositeOperation = 'source-over';
            ctx.clearRect(0, 0, canvas.width, canvas.height); 
            ctx.drawImage(imgOriginal, 0, 0, canvas.width, canvas.height);
        }

        function resetDrawing() {
            if (confirm("X√≥a m·ªçi v·∫øt t·∫©y v√† kh√¥i ph·ª•c ·∫£nh g·ªëc?")) {
                drawFullOriginal();
            }
        }

        function resetView() {
            const vW = viewport.clientWidth; const vH = viewport.clientHeight;
            const sW = vW / canvas.width; const sH = vH / canvas.height;
            scale = Math.min(sW, sH, 1) * 0.95;
            panX = (vW - canvas.width * scale) / 2;
            panY = (vH - canvas.height * scale) / 2;
            updateTransform();
            updateToolSize();
        }

        function updateTransform() {
            const transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
            stage.style.transform = transform;
            loupeDiv.style.backgroundSize = `${canvas.width * scale}px ${canvas.height * scale}px`;
        }

        // --- THANH C√îNG C·ª§ & ƒêI·ªÄU KHI·ªÇN ---
        
        function changeBrushSize(amount) {
            brushSize += amount;
            if (brushSize < 10) brushSize = 10;
            if (brushSize > 500) brushSize = 500;
            updateToolSize();
        }
        
        function updateToolSize() {
            brushSizeDisplay.innerText = brushSize + "px";
            touchCursor.style.width = brushSize + "px";
            touchCursor.style.height = brushSize + "px";
            loupeDiv.style.width = brushSize + "px";
            loupeDiv.style.height = brushSize + "px";
        }

        function nextImage() {
            loadPair(currentImageIndex + 1);
        }
        function prevImage() {
            loadPair(currentImageIndex - 1);
        }

        function setTool(toolName) {
            currentTool = toolName;
            Object.values(toolButtons).forEach(btn => btn.classList.remove('active'));
            if (toolButtons[toolName]) toolButtons[toolName].classList.add('active');
            
            if (toolName === 'loupe') touchCursor.style.borderColor = '#00e5ff';
            else if (toolName === 'eraser') touchCursor.style.borderColor = '#ff9800';
            else if (toolName === 'restore') touchCursor.style.borderColor = '#4CAF50';
        }

        function toggleView(showEdit) {
            canvas.style.opacity = showEdit ? '0' : '1';
        }

        function toggleUI(show) {
            if (show) {
                sidebarWrapper.classList.remove('hidden');
                showUIBtn.style.display = 'none';
            } else {
                sidebarWrapper.classList.add('hidden');
                showUIBtn.style.display = 'block';
            }
        }

        function swapSide() {
            sidebarWrapper.classList.toggle('left');
            showUIBtn.classList.toggle('left');
            if (sidebarWrapper.classList.contains('left')) {
                hideUIBtn.innerHTML = '‚ü®';
            } else {
                hideUIBtn.innerHTML = '‚ü©';
            }
        }

        // --- X·ª¨ L√ù C·∫¢M ·ª®NG (TOUCH) ---
        
        function getPosOnImage(clientX, clientY) {
            const r = viewport.getBoundingClientRect();
            const viewX = clientX - r.left;
            const viewY = clientY - r.top;
            return { 
                x: (viewX - panX) / scale, 
                y: (viewY - panY) / scale 
            };
        }

        function applyTool(clientX, clientY) {
            const toolX = clientX;
            const toolY = clientY + TOUCH_OFFSET_Y;
            
            touchCursor.style.left = toolX + 'px';
            touchCursor.style.top = toolY + 'px';
            touchCursor.style.display = 'block';
            
            const imgPos = getPosOnImage(toolX, toolY);
            const drawRadius = brushSize / 2 / scale;

            if (currentTool === 'loupe') {
                loupeDiv.style.left = toolX + 'px';
                loupeDiv.style.top = toolY + 'px';
                loupeDiv.style.display = 'block';
                const bgX = (-imgPos.x * scale) + (brushSize / 2);
                const bgY = (-imgPos.y * scale) + (brushSize / 2);
                loupeDiv.style.backgroundPosition = `${bgX}px ${bgY}px`;
                
            } else if (currentTool === 'eraser') {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.beginPath();
                ctx.arc(imgPos.x, imgPos.y, drawRadius, 0, Math.PI * 2);
                ctx.fill();
                
            } else if (currentTool === 'restore') {
                ctx.globalCompositeOperation = 'source-over';
                ctx.beginPath();
                ctx.arc(imgPos.x, imgPos.y, drawRadius, 0, Math.PI * 2);
                ctx.save();
                ctx.clip();
                ctx.drawImage(imgOriginal, 0, 0);
                ctx.restore();
            }
        }
        
        // --- B·ªò L·∫ÆNG NGHE S·ª∞ KI·ªÜN TOUCH ---

        viewport.addEventListener('touchstart', e => {
            if (e.touches.length === 1) {
                e.preventDefault();
                isDrawing = true;
                applyTool(e.touches[0].clientX, e.touches[0].clientY);
                
            } else if (e.touches.length === 2) {
                e.preventDefault();
                isDrawing = false; 
                isGesturing = true;
                
                touchCursor.style.display = 'none';
                loupeDiv.style.display = 'none';

                lastPanMidpoint = {
                    x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                    y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                };
                lastPinchDist = Math.hypot(
                    e.touches[1].clientX - e.touches[0].clientX,
                    e.touches[1].clientY - e.touches[0].clientY
                );
            }
        }, { passive: false });

        viewport.addEventListener('touchmove', e => {
            e.preventDefault();
            
            if (isDrawing && e.touches.length === 1) {
                applyTool(e.touches[0].clientX, e.touches[0].clientY);
                
            } else if (isGesturing && e.touches.length === 2) {
                
                // Pan
                const newMidpoint = {
                    x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                    y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                };
                panX += newMidpoint.x - lastPanMidpoint.x;
                panY += newMidpoint.y - lastPanMidpoint.y;
                lastPanMidpoint = newMidpoint;

                // Zoom
                const newPinchDist = Math.hypot(
                    e.touches[1].clientX - e.touches[0].clientX,
                    e.touches[1].clientY - e.touches[0].clientY
                );
                if (lastPinchDist === 0) lastPinchDist = newPinchDist;
                const scaleDelta = newPinchDist / lastPinchDist;
                
                const newScale = scale * scaleDelta;
                if (newScale >= 0.1 && newScale <= 50) {
                    const rect = viewport.getBoundingClientRect();
                    const mx = newMidpoint.x - rect.left;
                    const my = newMidpoint.y - rect.top;
                    
                    panX = mx - (mx - panX) * scaleDelta;
                    panY = my - (my - panY) * scaleDelta;
                    scale = newScale;
                }
                lastPinchDist = newPinchDist;

                updateTransform();
            }
        }, { passive: false });

        viewport.addEventListener('touchend', e => {
            isDrawing = false;
            isGesturing = false;
            lastPanMidpoint = null;
            
            touchCursor.style.display = 'none';
            loupeDiv.style.display = 'none';
        });

    </script>
</body>
</html>